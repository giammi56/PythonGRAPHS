#include "OS_Version.h"
#include "stdio.h"

void print_help()
{
	printf("command line syntax:\n");
	printf("\n");
	printf("lmf2root [config_file_name]\n");
	printf("\n");
	printf("examples:\n");
	printf("lmf2root config.txt\n");
	printf("\n");
	printf("lmf2root -bot\n   runs lmf2root as part of a bot net.");
	printf("\n");
	printf("allowed commands inside a config file:\n");
	printf("\n");
	printf("each command must end with a \";\"\n");
	printf("\n");
	printf("//      indicates a comment\n");
	printf("/*  */  C-Style comment block\n");
	printf("\n");
	printf("\n");
	printf("execute [other config file name]\n");
	printf("  executes another config file\n");
	printf("\n");
	printf("parameter [i] [x]\n");
	printf("  sets parameter number i to the value x\n");
	printf("\n");
	printf("\n");
	printf("beep\n");
	printf("  generates a \"beep\" sound\n");
	printf("\n");
	printf("\n");
	printf("feed_parameters_into_sorters\n");
	printf("  this command must be called after all necessary parameters have been set\n");
	printf("  and before the correction points are set. You can set parameters\n");
	printf("  between data files. This way it is possible to set parameters for each\n");
	printf("  data file.\n");
	printf("\n");
	printf("set_point [type] [detector] [layer] [position] [correction_value]\n");
	printf("  sets a correction point for the position dependend correction\n");
	printf("  of the time sums ([type] = sum) or the position non-linearity\n");
	printf("  ([type] = pos) for the 3 layers ([layer] = u or v or w)\n");
	printf("\n");
	printf("set_LMF_output_file_name [file_name]\n");
	printf("  sets the output file name for written LMFs. Use quotation marks\n");
	printf("  if there are whitespaces in the file name.\n");
	printf("\n");
	printf("\n");
	printf("set_root_output_file_name\n");
	printf("  sets the name for the output ROOT file. Use quotation marks\n");
	printf("  if there are whitespaces in the file name.\n");
	printf("\n");
	printf("readROOTfile [file_name]\n");
	printf("  reads a ROOT-file which should contain NTuples\n");
	printf("\n");
	printf("readLMF [file_name]\n");
	printf("  reads a LMF file which should contain NTuples\n");
	printf("\n");
	printf("\n");
	printf("\n");
	printf("\n");
	printf("How to calibrate a HEX-detector:\n");
	printf("\n");
	printf("It is important that the following sequence is\n");
	printf("followed striclty in this order:\n");
	printf("\n");
	printf("1) set w_offset to zero\n");
	printf("2) shift time sums to zero\n");
	printf("3) set time sum widths: half peak width base\n");
	printf("4) set the scalefactors so that the calibration is close to mm.\n");
	printf("   At this stage set all scalefactors equal.\n");
	printf("5) shift position picture to x/y=0. Note: the center of\n");
	printf("   the MCP is meant here. NOT the center of the hit distribution.\n");
	printf("6) set the runtime values for all layers.\n");
	printf("7) set the MCP radius\n");
	printf("8) activate the auto-calibration. Modify the scalefactors and\n");
	printf("   w_offset according to the results. Repeat this setp at least twice.\n");
	printf("9) Turn off auto-calibration\n");
	printf("10) check if the values for runtime and radius are still ok.\n");
	printf("11) during the last auto-calibration some correction tables were\n");
	printf("    written. Make sure to load these tables inthe config-file if\n");
	printf("    you want to use the sum correction and/or the non-linearity\n");
	printf("    correction. If you are using both types of correction then\n");
	printf("    check the histogram \"non_linearity\" afterwards.\n");
	printf("\n");
	printf("    NOTE: If you have used the sum correction or the NL-\n");
	printf("     	  correction during the sorting and if you want to read\n");
	printf("  	      back this sorted data afterwards then you must\n");
	printf("  	      deactivate the correction. Otherwise it would \"over correct\"\n");
	printf("		  the (already corrected) data!\n");
	printf("\n");
	printf("\n");
	printf("\n");
	printf("How to use the \"peak_tracker_class\" by Achim Czasch:\n");
	printf("\n");
	printf("make an instance of the peak_tracker_class:\n");
	printf("\n");
	printf("example:\n");
	printf("peak_tracker_class * tracker = peak_tracker_class::new_peak_tracker_class(20000,-w,w,int(2.*w/0.025+1.e-6)+1);\n");
	printf("\n");
	printf("this will initialze \"tracker\".\n");
	printf("\n");
	printf("Do not forget to delete tracker at the end of the prgram to prevent memory leaks:\n");
	printf("\n");
	printf("delete tracker;\n");
	printf("\n");
	printf("\"tracker\" will have an internal histogram.\n");
	printf("The center of the left bin will be at -w.\n");
	printf("The center of teh right bin will be at +w.\n");
	printf("The histogram is divided into\n");
	printf("int(2.*w/0.025+1.e-6)+1 bins.\n");
	printf("\n");
	printf("after 20000 fill commands \"tracker\" will calculate the center of mass\n");
	printf("of the histogram and then clear the histogram. This is called one \"cycle\".\n");
	printf("\n");
	printf("Before \"tracker\" can be used it needs some information.\n");
	printf("When you determine the position of a peak in a histogram you will\n");
	printf("probably get a slightly different results than the simple COM-calculation.\n");
	printf("Therefore you must tell \"tracker\" about this offset.\n");
	printf("This is done with\n");
	printf("\n");
	printf("tracker->offset_to_user_in_first_run = x\n");
	printf("\n");
	printf("The best way to get \"x\" is to create a histogram and fill\n");
	printf("it only with the first 20000 events (the first cycle).\n");
	printf("Then determine the position and feed the offset into \"tracker\".\n");
	printf("\n");
	printf("To prevent some pitfalls it is best to track a value which\n");
	printf("should be at zero.\n");
	printf("\n");
	printf("Now you can start to fill values into \"tracker\":\n");
	printf("\n");
	printf("tracker->track(value);\n");
	printf("\n");
	printf("Each time after such a fill you can ask tracker if it has\n");
	printf("produced a new correction offset (in other words \"if it has\n");
	printf("finished one cycle\"):\n");
	printf("\n");
	printf("if(tracker->is_new_result_available()) offset = offset - tracker->last_return_value;\n");
	printf("\n");
	printf("tracker->reset() clears the internal histogram.\n");
	printf("\n");
	printf("You can keep track of what \"tracker\" is doing by looking at the\n");
	printf("following member variables:\n");
	printf("\n");
	printf("bool   tracker->this_is_the_first_run (true during first cycle. False after first cycle.)\n");
	printf("int    tracker->internal_hit_counter (reset after each cycle)\n");
	printf("double tracker->maximum_return_up_to_now (maximum return value of all cycles)\n");
	printf("double tracker->maximum_total_correction_up_to_now (maximum total correction since start)\n");
	printf("int    tracker->number_of_resets\n");
	printf("int    tracker->overflows  (reset after each cycle)\n");
	printf("int    tracker->underflows (reset after each cycle)\n");
	printf("double tracker->sum_of_all_corrections_up_to_now (sum of all corrections. This is different from \"maximum_total_correction_up_to_now\".)\n");
	printf("\n");
	printf("The value \"tracker->maximum_total_correction_up_to_now\" helps to check\n");
	printf("whether a value has drifted too far.\n");
	printf("\n");
	printf("\n");
	printf("\n");
	printf("How to use presorters (Till Jahnke):\n\n");
	printf("A variety of predefined presorters of different type can be invoked in order to ");
	printf("tag events and only write these events to the ntuple.\n\n");
	printf("Syntax is in config file is \"new_presorter\" followed by the TYPE of the presorter, ");
	printf("the channel number the corresponding events are supposed to be tagged with and presorter ");
	printf("specfic parameters.\n\n");
	printf("Currently the following types are supported:\n\n");
	printf("ELECTRONTOF FLAG etof_center etof_width\n");
	printf("A simple presorter to find valid electron hits within a time-of-flight window ");
	printf("of pm etof_width centered at etof_center.\n");
	printf("The electron time-of-flight is obtained \"synchrotron-style\" by using the bunchmarker ");
	printf("channel (parameter 90) and fmod(bunchmarkerspacing) (parameter 99).\n");
	printf("All electron hits within the correct time window are written to the ntuple.\n");
	printf("If present the first ion of the event is written to the ntuple, as well\n\n");
	printf("RECELECTOF FLAG etof_center etof_width rtof_center rtof_width\n");
	printf("A presorter to find valid electron hits within a time-of-flight window ");
	printf("of pm etof_width centered at etof_center.\n");
	printf("The electron time-of-flight is obtained \"synchrotron-style\" by using the bunchmarker ");
	printf("channel (parameter 90) and fmod(bunchmarkerspacing) (parameter 99).\n");
	printf("Additionally only hits within a certain recoil time-of-flight window are considered valid. The recoils time-of-flight is: ");
	printf("REtof + Etof.\n");
	printf("All ions and electrons within the windows are written to the ntuple.\n\n");
	printf("PIPICO FLAG etof_center etof_width mass1_amu charge1_au mass2_amu charge2_au efield_Vcm acceleration_cm pipico_width_ns\n");
	printf("Single acceleration region PIPICO presorter.\n\n");
	printf("PIPIPICO FLAG etof_center etof_width mass1_amu charge1_au mass2_amu charge2_au mass3_amu charge3_au efield_Vcm acceleration_cm pipico_width_ns\n");
	printf("Single acceleration region PIPIPICO presorter for three-particle breakups.\n\n");


}
